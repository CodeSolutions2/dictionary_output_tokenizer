<!DOCTYPE html>
<html>
<head></head>
<body>

<!-- Text classification webapp -->
<!-- https://js.tensorflow.org/api/1.0.0/ -->
<h1 style='text-align: center; margin-bottom: -35px;'>Text classification webapp</h1>
<br><br>

<!-- [Step 0] Train model -->
<label for="train_dataset_url_label" style="display:block">Enter train dataset location url: url can be Github or GCP storage (ie: https://github.com/CodeSolutions2/text_classification_w_labels/train_dataset.csv):</label>
<input type="text" value="" placeholder="Train dataset url" id="train_dataset_url" rows="1" cols="500" style="display:block">
<br>
<button id="train_model" onclick="train_model()" style="display:block">train_model</button>

	
<!-- [Step 1] Result: say if model is trained or not -->
<div id="output" style="font-family:courier;font-size:24px;height:300px"></div>

	
<!-- [Step 2] Predict/inference: predict each sentence separated by a \n character -->
<label for="input_text_label" style="display:none">Enter text to label, each sentence separated by the \n character will be labeled:</label>
<input type="text" value="" placeholder="Enter text to label" id="input_text" rows="10" cols="500" style="display:none">



	
<!-- https://developer.mozilla.org/en-US/docs/Web/CSS/position -->
<style>
canvas {border: 1px solid black; position: absolute; display: inline-block; z-index: 1; top: 150px;},
div {position: relative; z-index: 2;},
table {border-collapse: collapse;}
td,
th {border: 1px solid black; padding: 10px 20px;}
</style>

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>

<script>

  // -------------------------------------------------
	
  const outp = document.getElementById('output');

  var url_vec = [];  // This is a global variable, and I start referencing it in get_train_dataset


	const xs = [];
	   const ys = [];
	
  // -------------------------------------------------

	
  async function get_train_datasetURL() {

	// https://github.com/CodeSolutions2/text_classification_w_labels/train_dataset0.csv
	// https://storage.googleapis.com/BUCKET_NAME/train_dataset.csv
	const datasetUrl = document.getElementById("train_dataset_url").value;

	let out = datasetUrl.split("/")

	outp.innerHTML += "out: " + out + "<br/>";
	
	let domain_name = out[2];
	
	if (domain_name == 'github.com'){
		const repoOwner = out[3];
		const repoName = out[4];

		outp.innerHTML += "repoOwner: " + repoOwner + "<br/>";
		outp.innerHTML += "repoName: " + repoName + "<br/>";
		
		var url = `https://api.github.com/repos/${repoOwner}/${repoName}/contents`;
		    //var options = {method : 'get', headers: headers, mode: 'no-cors'};
		    await fetch(url).then(res => res.json()).then(data => {
		    data.forEach(file => {
		      if (file.type === 'file' && file.name.match(/.(csv|txt)$/i)) {
		        
		        //outp.innerHTML += "Filename=" + file.name + ", file url=" + file.download_url + "<br/>";
			url_vec.push(file.download_url);
		      }
		    });
		  }).catch(error => { outp.innerHTML += error; });

	} else if (domain_name == 'storage.googleapis.com') {
		url_vec.push(datasetUrl);
		
	} else {
		outp.innerHTML = 'Please enter a GitHub repository or Google Cloud Platform Storage URL';
	}
	
 
	return url_vec;
  }
	
	
  // -------------------------------------------------

	
  async function train_model() {

    // ---------------------------

    // [Step 0] Read in a list of urls that are .csv or .txt files
    
    var url_vec = await get_train_datasetURL();
    outp.innerHTML += 'url_vec: ' + url_vec + "<br/>";

    // ---------------------------
	  
    // [Step 1] Load custom model
	  
    // Way 0: load pre-trained model
    // const MODEL_URL = 'https://storage.googleapis.com/tensorflowjsmodels0/model.json';
    // const MODEL_URL = 'model.json';
    // const custom_model = await tf.loadLayersModel(MODEL_URL);

    // OR

    // Way 1: load model layers using sequential
    // const NUM_WORDS = ;
    // const EMBEDDING_DIM = 256;
    //  const MAXLEN 
    //  const num_of_classes
    // const custom_model = tf.sequential();
    // custom_model.add( tf.layers.embedding(inputDim=NUM_WORDS, outputDim=EMBEDDING_DIM, inputLength=MAXLEN) );
    // custom_model.add( tf.layers.globalAveragePooling1d() );
    // custom_model.add( tf.layers.dense(num_of_classes, activation='softmax') );

    // OR

    // Way 2: load model layers using functional API (tf.LayersModel)
	  
    // ---------------------------

    // custom_model.compile({optimizer='adam', loss='sparse_categorical_crossentropy', metrics=["accuracy"]});
	  
    // ---------------------------
	  
    // [Step 2] Select a url from the url list
	  
    // url_vec.forEach(function(csvUrl, index) {
    // Does not make sense to train the model for every dataset found.
    // It makes more sense to train the model on one seleccted dataset, then test it with predictions.

    const csvUrl = url_vec[0];

    // ---------------------------

    // [Step 3] Make a Dataset
	  
    // X and y (dataset object)
    const csvDataset = await tf.data.csv(csvUrl, { columnConfigs: { Y: {isLabel: true} } });
    outp.innerHTML += 'csvDataset: ' +  csvDataset + "<br/>";  // csvDataset: [object Object]
	    
    // ---------------------------
	  
    // Number of columns
    const num_of_cols = (await csvDataset.columnNames()).length;
    outp.innerHTML += 'num_of_cols: ' + num_of_cols + "<br/>";

   const column_names = (await csvDataset.columnNames());
   outp.innerHTML += 'column_names: ' + column_names + "<br/>";
	  
    // ---------------------------
	  
	  
    // });  // end of forEach


    // ---------------------------

    // [Step 4] Clean the dataset
    await modify_X_Y(csvDataset).then((xs, ys) => { outp.innerHTML += 'xs: ' + xs + "<br/>"; outp.innerHTML += 'ys: ' + ys + "<br/>"; } );
	  
    // ---------------------------

    // [Step 5] Tokenize X
	  

    // ---------------------------

    // [Step 5] Tokenize Y

    // ---------------------------

    // [Step 5] Fit the model using the prepared Dataset
   // await custom_model.fitDataset(flattenedDataset, {
   //   epochs: 10,
   //   callbacks: {
   //     onEpochEnd: async (epoch, logs) => { console.log(epoch + ':' + logs.loss); }
    //  }
   // });

    // ---------------------------

    return	

  }  // end of train_model

	
  // -------------------------------------------------


	
  // -------------------------------------------------


  async function modify_X_Y(csvDataset) {

	  //  Same output as csvDataset, so just using csvDataset directly
	  // This is an object, and can iterate over values in the Object
	  // const flattenedDataset = await csvDataset.map(({xs, ys}) => { return {xs:Object.values(xs), ys:Object.values(ys)}; });
	  // outp.innerHTML += 'flattenedDataset: ' +  flattenedDataset + "<br/>";
	  // const csv_iterator_values = await flattenedDataset.iterator()
	  
	  // OR
	  
	  // This is an object, and can iterate over values in the Object
	  const csv_iterator = await csvDataset.iterator();

	  // OR
	  
	  // No output 
	  // const datasetArray1 = await Array.from(csvDataset)
	  // outp.innerHTML += 'datasetArray1: ' + datasetArray1 + "<br/>";

	  // OR

	  // dataout is empty
	  // const tensors = await csvDataset.toArray().then(tensors => { outp.innerHTML += 'dataout: ' + tf.tensor(tensors).dataSync() + "<br/>"; return tensors;});
	// so this function only has the objects after it returns, it is useless to use a then()

	  const tensors = await csvDataset.toArray();

	  // tensors.length: 10
	  outp.innerHTML += 'num_of_rows = tensors.length: ' + tensors.length + "<br/>";  

	  // tensors: [object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object]
	  outp.innerHTML += 'tensors: ' + tensors + "<br/>";
	  
	  
	  // ---------------------------

	  tensors.forEach(async function(rowdata, index) {

		  // Try 0
		outp.innerHTML += 'rowdata: ' + rowdata + "<br/>";
		outp.innerHTML += 'index: ' + index + "<br/>";

		  // valueNames: xs,ys
	      if (index == 0) { const valueNames = Object.keys(rowdata.value); outp.innerHTML += 'valueNames: ' + valueNames + "<br/>";}

		const X = Object.values(rowdata.value.xs);
		outp.innerHTML += 'X: ' + X + "<br/>";
		
		const Y = Object.values(rowdata.value.ys);
		outp.innerHTML += 'Y: ' + Y + "<br/>";

		// Make text lower case
		// TypeError: X.toLowerCase is not a function
		// X = X.toLowerCase();
		// Y = Y.toLowerCase();
		  
		xs.push(X)
		ys.push(Y)
	
	// OR
		  
	// Try 1
	// values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray
	// means that row.value.xs does not have a value
	// await csv_iterator.next().then(row => {tf.tensor(row.value.xs).dataSync()}).then( row => {

	// OR

	// Try 2
	// values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray
	// await csv_iterator.next().then(row => {tf.tensor(row).dataSync()}).then( (x,y) => {

	// OR

	// Try 3: Best
	//await csv_iterator.next().then(row => {

	// OR

	// Try 4: Works like Try 3
	// await csv_iterator_values.next().then(row => {
		
	      // row is [object Object] for Try 2
	     // outp.innerHTML += 'row: ' + row + "<br/>";

	      // --------------------------------------
	      // Get values from the object row
	      // const get_rowvalues = row.dataSync();
		
	      // OR
		
	      //async (row) => {
		//      const X_tensor = await tf.tensor(row.value.xs).dataSync();
		//      outp.innerHTML += 'X_tensor: ' + X_tensor + "<br/>";
	     // };

	      // OR

		// row.map is not a function
	      //row.map(({xs, ys}) => {
		//	outp.innerHTML += 'xs: ' + xs + "<br/>";
		//	outp.innerHTML += 'ys: ' + ys + "<br/>";
	      // })
	      // --------------------------------------

	      // --------------------------------------
	      // Assign X and Y
		
	      // valueNames: value,done
	      // if (index == 0) { const valueNames = Object.keys(row); outp.innerHTML += 'valueNames: ' + valueNames + "<br/>";}

		// ----------------------- Works
              // valueNames: xs,ys
	   //   if (index == 0) { const valueNames = Object.keys(row.value); outp.innerHTML += 'valueNames: ' + valueNames + "<br/>";}

	//	const X = Object.values(row.value.xs);
		//outp.innerHTML += 'X: ' + X + "<br/>";
		
		//const Y = Object.values(row.value.ys);
		//outp.innerHTML += 'Y: ' + Y + "<br/>";

		  // ------------------------------------------
		// Make text lower case
		// TypeError: X.toLowerCase is not a function
		// X = X.toLowerCase();
		// Y = Y.toLowerCase();

		  // Remove characters between parenthesis
	      //X.replace(/\((.*?)\)/g, '');
	      //X.replace(/\{(.*?)\}/g, '');
	      //X.replace(/\[(.*?)\]/g, '');
	
	      // [Step 3] Remove undesireable words 
	
	      // [Step 4] Remove sentences with less than 10 words. Narrow the sentences down to realistic sentences.
		// ------------------------------------------
		  
		// xs.push(X)
		//ys.push(Y)
	
	//});  // end of await csv_iterator.next().then(row =>


	  });  // end of forEach


  }

	
  // -------------------------------------------------

	
  async function predict_with_custom_model(y_assignment) {
    
    var pred_vec = [['', '', ''],['row', 'prediction', 'probability']]; 

    const text_input = document.getElementById("input_text").value;

    text_input = text_input.split("\n")

    // ---------------------------
	  
    // Tokenize X
    // sequence_array
	  
    // ---------------------------

    var pred_vec = [];
		  
    sequence_array.forEach(async function(seq, ind) {
	  
	    // Call the custom_model 
	    const result = custom_model.predict(seq) ;

	    // Get index of maximum softmax probability 
	    const index = result.as1D().argMax().dataSync()[0];
			
	    // Get maximum softmax probability 
	    const resultData = await result.data();    
	    const maxprob = resultData[index];

	    pred_vec.push([y_assignment[index], maxprob]);    
    
    });  // end of forEach

    // ---------------------------
	  
    // Save array to csv and put download csv file link on screen (NO AUTOMATIC DOWNLOADING)
    await put_results_in_CSVfile(pred_vec);

    // Create a table dynamically with the results
    await generateTable_dynamically(pred_vec);

    // ---------------------------	

  }  // end of predict_with_custom_model

	
  // -------------------------------------------------

	
  async function put_results_in_CSVfile(pred_vec) {
    
    // ---------------------
    // Puts array into csv format
    const blob = new Blob([pred_vec], { type: 'text/csv;charset=utf-8;' });

    // Create a url for the data object
    const url = URL.createObjectURL(blob);
    // ---------------------
    // OR
    // ---------------------
    // Puts array into csv format
    // let csvContent = "data:text/csv; charset=utf-8";
    // pred_vec.forEach(function(row_array) {
	// csvContent += row_array.join(",") + "\r\n";
    // });
    // OR
    // let csvContent = "data:text/csv;charset=utf-8," + rows.map(e => e.join(",")).join("\n");
	  
    // Create a url for the data object
    // var url = encodeURI(csvContent);
    // ---------------------

    const link = document.createElement("a");
    link.setAttribute("href", url);

    const filename = 'data.csv';
    link.setAttribute("download", filename);
	  
    link.style.display = 'block';

    outp.innerHTML += 'Download CSV here: ' + url + "<br/>";
    // document.body.appendChild(link);

    // Automatic download of csv
    // link.click();
    // document.body.removeChild(link);
	  
  }

	
  // -------------------------------------------------

	
  async function generateTable_dynamically(pred_vec) {

  	const tbl = document.createElement("table");
  
  	const tblBody = document.createElement("tbody");
  
  	// Create row cells dynamically
  	for (let i=0; i < pred_vec.length; i++){
  		// create a table row
  		const row = document.createElement("tr");
  
  		for (let j=0; j < pred_vec[0].length; j++){
  			const cell = document.createElement("td");
  			const cellText = document.createTextNode(`${pred_vec[i][j]}`);
  			cell.appendChild(cellText);
  			row.appendChild(cell);
  		}
  
  		// add a row to the end of the table
  		tblBody.appendChild(row);
  	}
  	tbl.appendChild(tblBody);
  
  	document.body.appendChild(tbl);

  }  

  // -------------------------------------------------

	
</script>
</body>
</html>
